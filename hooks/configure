#!/usr/bin/python3
#
# Copyright (C) 2017 Canonical Ltd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import sys

from subprocess import (
    CalledProcessError,
    check_call,
    check_output,
    run,
    DEVNULL,
    PIPE,
)


# list of services we can disable and enable
SERVICES=("ssh",)


def core_support_available():
    """Return true if core_support interface is available

    The check is done indirectly via checking if systemctl can be used.
    """
    try:
        check_call(["systemctl", "--version"], stdout=DEVNULL, stderr=DEVNULL)
    except CalledProcessError:
        return False
    return True


def switch_handle_power_key(action):
    valid_actions = ("ignore","poweroff","reboot","halt","kexec","suspend","hibernate","hybrid-sleep","lock")
    login_conf_d=os.getenv("TEST_LOGIN_CONF_D", default="/etc/systemd/logind.conf.d")
    conf=os.path.join(login_conf_d, "00-snap-core.conf")

    if not os.path.isdir(login_conf_d):
        os.makedirs(login_conf_d)
    if not action in valid_actions:
        raise Exception("invalid action '{}' supplied for system.power-key-action option".format(action))
    with open(conf+".tmp", "w") as fp:
        fp.write("[Login]\nHandlePowerKey={}\n".format(action))
    os.rename(conf+".tmp", conf)


def switch_service(service, enable):
    srv = "{}.service".format(service)
    if enable == "true":
 	# A simple `systemctl disable --now ssh.service` doesn't work
 	# and fails with an error message. Because of that we're going
 	# in two steps here and disable first and then stopping the
 	# service unit.
        check_call(["systemctl", "disable", srv])
        check_call(["systemctl", "stop", srv])
    elif enable == "false":
 	# When the unit is already enabled but not active a call with
 	# --now does start the unit so we have to check for that  case
 	# and explicitly start the unit.
        
        if run(["systemctl", "is-enabled", srv], universal_newlines=True, stdout=PIPE).stdout.strip() == "disabled":
            check_call(["systemctl", "enable", srv])
        if run(["systemctl", "is-active", srv], universal_newlines=True, stdout=PIPE).stdout.strip() == "inactive":
            check_call(["systemctl", "start", srv])
    else:
        raise Exception("Invalid value '{}' provided for option {}".format(enable, srv))


def update_pi_config_value(path, key, value):
    with open(path) as r, open(path+".tmp", "w") as w:
        found=False
        for line in r:
            m=re.match(r'^[ \t#]*({}=.*)$'.format(key), line)
            if m:
                if value == "":
                    line="#{}\n".format(m.group(1))
                else:
                    line="{}={}\n".format(key, value)
                found=True
            w.write(line)
        if not found and value != "":
            w.write("{}={}\n".format(key, value))
    os.rename(path+".tmp", path)
            

if __name__ == "__main__":
    if not core_support_available():
        print("Cannot run systemctl - is core-support available?")
        sys.exit(0)

    for service in SERVICES:
        value=check_output(["snapctl", "get", "service.{}.disable".format(service)], universal_newlines=True).strip()
        if value != "":
            switch_service(service, value)
    
    powerkey=check_output(["snapctl", "get", "system.power-key-action"], universal_newlines=True).strip()
    if powerkey != "":
        switch_handle_power_key(powerkey)

    PI_CONFIG_KEYS=[
        "disable_overscan", "framebuffer_width", "framebuffer_height",
        "framebuffer_depth", "framebuffer_ignore_alpha", "overscan_left",
        "overscan_right", "overscan_top", "overscan_bottom", "overscan_scale",
        "display_rotate", "hdmi_group", "hdmi_mode", "hdmi_drive",
        "avoid_warnings", "gpu_mem_256", "gpu_mem_512", "gpu_mem",
    ]
    PI_CONFIG=os.getenv("TEST_UBOOT_CONFIG", default="/boot/uboot/config.txt")
    if os.path.isfile(PI_CONFIG):
        for key in PI_CONFIG_KEYS:
            value=check_output(["snapctl", "get", "pi-config.{}".format(key.replace("_","-"))], universal_newlines=True).strip()
            update_pi_config_value(PI_CONFIG, key, value)

