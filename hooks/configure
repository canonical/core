#!/usr/bin/python3 -SIBbb
#
# Copyright (C) 2017 Canonical Ltd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import subprocess
import sys

from subprocess import check_output

# list of services we can disable and enable
SERVICES=("ssh",)


def systemctl(*args, check=False):
    res = subprocess.run(["systemctl"]+list(args), stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
    if check:
        res.check_returncode()
    return res


def core_support_available():
    """Return true if core_support interface is available

    The check is done indirectly via checking if systemctl can be used.
    """
    return systemctl("--version").returncode == 0


def _filesync(fp):
    fp.flush()
    os.fsync(fp.fileno())

def _dirsync(path):
    os.rename(path+".tmp", path)
    dfd=os.open(os.path.dirname(path), os.O_RDONLY)
    try:
        os.fsync(dfd)
    finally:
        os.close(dfd)


def switch_handle_power_key(action):
    valid_actions = ("ignore","poweroff","reboot","halt","kexec","suspend","hibernate","hybrid-sleep","lock")
    login_conf_d=os.getenv("TEST_LOGIN_CONF_D", default="/etc/systemd/logind.conf.d")
    conf=os.path.join(login_conf_d, "00-snap-core.conf")

    if not os.path.isdir(login_conf_d):
        os.makedirs(login_conf_d)
    if not action in valid_actions:
        raise Exception("invalid action {!r} supplied for system.power-key-action option".format(action))
    with open(conf+".tmp", "w") as fp:
        fp.write("[Login]\nHandlePowerKey={}\n".format(action))
        _filesync(fp)
    _dirsync(conf)

def switch_service(service, enable):
    srv = "{}.service".format(service)
    if enable == "true":
 	# A simple `systemctl disable --now ssh.service` doesn't work
 	# and fails with an error message. Because of that we're going
 	# in two steps here and disable first and then stopping the
 	# service unit.
        systemctl("disable", srv)
        systemctl("stop", srv)
    elif enable == "false":
 	# When the unit is already enabled but not active a call with
 	# --now does start the unit so we have to check for that  case
 	# and explicitly start the unit.
        if systemctl("is-enabled", "--quiet", srv).returncode != 0:
            systemctl("enable", srv, check=True)
        if systemctl("is-active", "--quiet", srv).returncode != 0:
            systemctl("start", srv, check=True)
    else:
        raise Exception("Invalid value {!r} provided for option {}".format(enable, srv))

def update_pi_config(path, config):
    to_write=[]
    needs_write=False
    with open(path) as r:
        found=set()
        rx=re.compile(r'^[ \t]*?(?P<is_comment>#?)[ \t#]*?(?P<key>{})=(?P<old_value>.*)$'.format("|".join(config)))
        for line in r:
            m=rx.match(line)
            if m is not None:
                key=m.group("key")
                was_comment=m.group("is_comment") == "#"
                old_value=m.group("old_value")
                found.add(key)
                if config[key]:
                    if was_comment or old_value != config[key]:
                        line="{}={}\n".format(key, config[key])
                        needs_write=True
                else:
                    line="#{}={}\n".format(key, old_value)
                    if not was_comment:
                        needs_write=True
            to_write.append(line)
        for key in set(config)-found:
            if config[key]:
                needs_write=True
                to_write.append("{}={}\n".format(key, config[key]))
    if needs_write:
        with open(path+".tmp", "w") as w:
            for line in to_write:
                w.write(line)
            _filesync(w)
        _dirsync(path)

if __name__ == "__main__":
    if not core_support_available():
        print("Cannot run systemctl - is core-support available?")
        sys.exit(0)

    for service in SERVICES:
        value=check_output(["snapctl", "get", "service.{}.disable".format(service)], universal_newlines=True).strip()
        if value != "":
            switch_service(service, value)

    powerkey=check_output(["snapctl", "get", "system.power-key-action"], universal_newlines=True).strip()
    if powerkey != "":
        switch_handle_power_key(powerkey)

    PI_CONFIG_KEYS=[
        "disable_overscan", "framebuffer_width", "framebuffer_height",
        "framebuffer_depth", "framebuffer_ignore_alpha", "overscan_left",
        "overscan_right", "overscan_top", "overscan_bottom", "overscan_scale",
        "display_rotate", "hdmi_group", "hdmi_mode", "hdmi_drive",
        "avoid_warnings", "gpu_mem_256", "gpu_mem_512", "gpu_mem",
    ]
    PI_CONFIG=os.getenv("TEST_UBOOT_CONFIG", default="/boot/uboot/config.txt")
    if os.path.isfile(PI_CONFIG):
        config={}
        # TODO: snapctl can actually give us the whole dict in JSON,
        # in a single call; use that instead of this.
        for key in PI_CONFIG_KEYS:
            value=check_output(["snapctl", "get", "pi-config.{}".format(key.replace("_","-"))], universal_newlines=True).strip()
            config[key]=value
        update_pi_config(PI_CONFIG, config)

